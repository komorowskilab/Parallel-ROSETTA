//-------------------------------------------------------------------
// Author........: Ewa Makosa
// Date..........:
// Description...:
// Revisions.....:
//===================================================================

#include <stdafx.h> // Precompiled headers.
#include <copyright.h>

#include <kernel/algorithms/cppgeneralruleexporter.h>
#include <kernel/structures/generalrules.h>
#include <kernel/structures/generalrule.h>
#include <kernel/utilities/systemkit.h>
#include <kernel/system/fstream.h>
#include <kernel/system/iostream.h>
#include <kernel/basic/message.h>

//-------------------------------------------------------------------
// Static helpers.
//===================================================================

//-------------------------------------------------------------------
// Method........: StaticGetName
// Author........: Ewa Makosa
// Date..........:
// Description...:
// Comments......:
// Revisions.....:
//===================================================================

static String
StaticGetName(const DecisionTable &table, int attribute_no, bool masked) {

	String name = table.GetAttributeName(attribute_no, masked);

	name.Replace(' ', '_');
	name.Capitalize();

	return name;

}

//-------------------------------------------------------------------
// Methods for class CPPGeneralRuleExporter.
//===================================================================

//-------------------------------------------------------------------
// Constructors/destructor.
//===================================================================

CPPGeneralRuleExporter::CPPGeneralRuleExporter() {
}

CPPGeneralRuleExporter::~CPPGeneralRuleExporter() {
}

//-------------------------------------------------------------------
// Methods inherited from Identifier.
//===================================================================

IMPLEMENTIDMETHODS(CPPGeneralRuleExporter, CPPGENERALRULEEXPORTER, RuleExporter)

//-------------------------------------------------------------------
// Method........: IsApplicable
// Author........: EwaMakosa
// Date..........:
// Description...: Returns true if the algorithm is applicable to the
//                 structure, false otherwise.
// Comments......:
// Revisions.....:
//===================================================================

bool
CPPGeneralRuleExporter::IsApplicable(const Structure &structure, bool /*warn*/) const {
	return structure.IsA(GENERALRULES);
}

//-------------------------------------------------------------------
// Methods inherited from Exporter.
//===================================================================



//-------------------------------------------------------------------
// Method........: ExportData
// Author........: Ewa Makosa
// Date..........:
// Description...: Exports the implementation (.cpp) file.
// Comments......:
// Revisions.....:
//===================================================================

bool
CPPGeneralRuleExporter::ExportData(ofstream &stream, const Structure &structure) const {

	int i, j, k;

	Message message;

	// Cast to already verified type (in Apply method).
	Handle<GeneralRules> rules = dynamic_cast(GeneralRules *, const_cast(Structure *, &structure));

	// Get originating decision table.
	Handle<DecisionTable> table = dynamic_cast(DecisionTable *, rules->FindParent(DECISIONTABLE));

	if (table == NULL) {
		message.Error("Could not trace back to the rules' originating decision table for a dictionary.");
		return false;
	}

	bool masked = true;

	int no_attributes = table->GetNoAttributes(masked);
	int decision_attribute = table->GetDecisionAttribute(masked);

	Vector(int) decisionvalues;
	Vector(int) cardinalities;

	table->GetValueSet(decisionvalues, cardinalities, decision_attribute, masked);

	// Write marker.
	stream << "//------------------------------------------------------------------" << endl;
	stream << "// The implementation (.cpp) file starts here."                       << endl;
	stream << "//==================================================================" << endl;
	stream << endl;

	// Write some general information.
	stream << "// Classifier generated by ROSETTA."                                                << endl;
	stream << "// Exported " << SystemKit::GetTimestamp() << " by " << SystemKit::GetUser() << "." << endl;
	stream << "//"                                                                                 << endl;
	stream << "// " << rules->GetName()                                                            << endl;
	stream << "// " << rules->GetNoRules() << " rules."                                            << endl;
	stream << endl;

	// Add #include section.
	stream << "// To do: Change the name below to whatever you named the header (.h) file." << endl;
	stream << "#include \"" << GetFilename() << "\"" << endl;
	stream << "#include <string.h> // strcmp." << endl;
	stream << "#include <limits.h> // INT_MAX." << endl;
	stream << endl;

	// Add #define section.
	stream << "//------------------------------------------------------------------" << endl;
	stream << "// Method........: Macros"                                            << endl;
	stream << "// Author........: Ewa Makosa"                                   << endl;
	stream << "// Date..........: " << SystemKit::GetTimestamp()                     << endl;
	stream << "// Description...:"                                                   << endl;
	stream << "//==================================================================" << endl;
	stream << endl;
	stream << "#define ROSETTALOOKUP(description, value) \\"                         << endl;
	stream << "if (0 == strcmp(text, description)) return value;"                    << endl;
	stream << endl;
	stream << "#define ROSETTAMATCH(attribute, value) \\"                            << endl;
	stream << "Match##attribute##(object.##attribute, value)"                        << endl;
	stream << endl;
	stream << "#define ROSETTAVOTE(";

	for (i = 0; i < decisionvalues.size(); i++) {
	  stream << "index" << i << ", votes" << i;
		if (i < decisionvalues.size() - 1)
			stream << ", ";
	}

	stream << ") \\"                                                                 << endl;
	stream << '{';

	for (i = 0; i < decisionvalues.size(); i++) {
	  stream << "votes[index" << i << "] += votes" << i << "; ";
	}

	stream << "no_matches++;}"                                                       << endl;
	stream << endl;

	// Add method header.
	stream << "//------------------------------------------------------------------"                    << endl;
	stream << "// Method........: Lookup methods"                                                       << endl;
	stream << "// Author........: Ewa Makosa"                                                      << endl;
	stream << "// Date..........: " << SystemKit::GetTimestamp()                                        << endl;
	stream << "// Description...: Converts symbolic values to integers."                                << endl;
	stream << "//=================================================================="                    << endl;
	stream << endl;

	for (i = 0; i < no_attributes; i++) {

		if (!table->IsCondition(i, masked) || !table->IsSymbolic(i, masked))
			continue;

		// Method name.
		stream << "int"                                                                                   << endl;
		stream << "ROSETTAObject::Lookup" << StaticGetName(*table, i, masked) << "(const char *text) {"   << endl;
		stream << endl;

		Vector(int) conditionvalues;

		table->GetValueSet(conditionvalues, cardinalities, i, masked);

		// Method body.
		for (j = 0; j < conditionvalues.size(); j++) {
			String description = table->GetDictionaryEntry(i, conditionvalues[j], masked);
			stream << "  ROSETTALOOKUP(\"" << description << "\", " << String(' ', 25 - description.GetLength()) << conditionvalues[j] << ')' << endl;
		}

		stream << endl;
		stream << "  return INT_MAX;"                                                                     << endl;
		stream << endl;
    stream << "}"                                                                                     << endl;
		stream << endl;

	}

	Map(int, int) decisionmap;

	for (i = 0; i < decisionvalues.size(); i++)
		decisionmap.insert(Pair(const int, int)(decisionvalues[i], i));

	// Build index map.

	int no_rules = rules->GetNoRules();

	// Add method header.
	stream << "//------------------------------------------------------------------"                    << endl;
	stream << "// Method........: Classify"                                                             << endl;
	stream << "// Author........: Ewa Makosa"                                                      << endl;
	stream << "// Date..........: " << SystemKit::GetTimestamp()                                        << endl;
	stream << "// Description...: Classifies an object using standard voting among"                     << endl;
	stream << "//                 a set of decision rules."                                             << endl;
	stream << "//"                                                                                      << endl;
	stream << "//                 Returns the number of matching rules. In-place is"                    << endl;
	stream << "//                 returned an array with the vote counts for each"                      << endl;
	stream << "//                 decision value. To map from array indices to decision"                << endl;
	stream << "//                 values, use the following legend:"                                    << endl;
	stream << "//"                                                                                      << endl;

	for (Map(int, int)::iterator it = decisionmap.begin(); it != decisionmap.end(); it++)
	  stream << "//                 " << (*it).second << " -> \"" << table->GetDictionaryEntry(decision_attribute, (*it).first, masked) << "\"" << endl;

	stream << "//"                                                                                      << endl;
	stream << "//=================================================================="                    << endl;
	stream << endl;
	stream << "int"                                                                                     << endl;
	stream << "ROSETTAClassifier::Classify(const ROSETTAObject &object, int votes[" << decisionvalues.size() << "]) const {" << endl;
	stream << endl;
	stream << "  int no_matches = 0;"                                                                   << endl;
	stream << endl;

	// Add array initialization.
	stream << "  for (int i = 0; i < " << decisionvalues.size() << "; i++)"                             << endl;
	stream << "    votes[i] = 0;"                                                                       << endl;

	stream << endl;

	bool has_issued_warning = false;

	// Add rules.
	for (i = 0; i < no_rules; i++) {

		if (!message.Progress("Exporting rules...", i, no_rules))
			break;

		Handle<GeneralRule> rule  = rules->GetRule(i);
		int no_descriptors = rule->GetNoConditionDescriptors();
		int no_decisions   = rule->GetNoDecisionValues();

		// Quick sanity check.
		if (rule->GetDecisionAttribute() != decision_attribute) {
			if (!has_issued_warning) {
				message.Warning("Possible mismatch in table and rule set for decision attribute.", false);
				has_issued_warning = true;
			}
		}

		stream << "  if (";

		// Write if-part.
		for (j = 0; j < no_descriptors; j++) {

			int descriptor_attribute = rule->GetConditionAttribute(j);
			GeneralRule::ValueSet::const_iterator descriptor_value_it = rule->GetConditionValueIterator(j);
		
			int no_values = rule->GetNoConditionValues(j);
			
			int v;
			
			String name = StaticGetName(*table, descriptor_attribute, masked);
			
			//Message::Warning("Rule "+String::Format(i)+" descriptor "+name+" has novalues = "+String::Format(no_values));
			if (no_values > 1)
				stream << "(";
			int c = 0;

			// Method name and parameters.
			if (table->IsFloat(descriptor_attribute, masked)){
				for (v = 0; v < no_values; v++){
					int descriptor_value = *descriptor_value_it;
						stream << "ROSETTAMATCH(" << name << ", " << table->GetDictionaryEntry(descriptor_attribute, descriptor_value, masked) << ')';
					if (v < no_values - 1)
						stream << " || ";
					descriptor_value_it++;
				}
				
			}
			else{
				for (v = 0; v < no_values; v++){
					int descriptor_value = *descriptor_value_it;
						stream << "ROSETTAMATCH(" << name << ", " << descriptor_value << ')';
					if (v < no_values - 1)
						stream << " || ";
					descriptor_value_it++;
				}
				
			}

			if (no_values > 1)
				stream << ")";

			if (j < no_descriptors - 1)
				stream << " && ";
			else
				stream << ')';

		}

		stream << endl;

		// Write then-part.
		stream << "    ROSETTAVOTE(";
		for (k = 0; k < decisionvalues.size(); k++) {
			bool did_vote = false;
			for (j = 0; j < no_decisions; j++) {
				int decision_value = rule->GetDecisionValue(j);
				int mapped_value   = decisionmap[decision_value];
				if (mapped_value == k) {
					stream << mapped_value << ", " << rule->GetSupport(j);
					did_vote = true;
					break;
				}
			}
			if (!did_vote) {
				stream << k << ", 0";
			}
			if (k < decisionvalues.size() - 1)
				stream << ", ";
		}
		stream << ')' << endl;
		stream << endl;

	}

	stream << "  return no_matches;" << endl;
	stream << endl;
	stream << '}' << endl;
	stream << endl;

	// Write marker.
	stream << "//------------------------------------------------------------------" << endl;
	stream << "// The implementation (.cpp) file ends here."                         << endl;
	stream << "//==================================================================" << endl;
	stream << endl;

	return true;

}

CPPGeneralRuleExporter *
CPPGeneralRuleExporter::Clone() {
   return new CPPGeneralRuleExporter;
} 
