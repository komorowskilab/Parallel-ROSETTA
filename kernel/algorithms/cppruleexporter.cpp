//-------------------------------------------------------------------
// Author........: Aleksander šhrn
// Date..........:
// Description...:
// Revisions.....:
//===================================================================

#include <stdafx.h> // Precompiled headers.
#include <copyright.h>

#include <kernel/algorithms/cppruleexporter.h>

#include <kernel/structures/rules.h>
#include <kernel/structures/rule.h>

#include <kernel/utilities/systemkit.h>

#include <kernel/system/fstream.h>

#include <kernel/basic/message.h>

//-------------------------------------------------------------------
// Static helpers.
//===================================================================

//-------------------------------------------------------------------
// Method........: StaticGetName
// Author........: Aleksander šhrn
// Date..........:
// Description...:
// Comments......:
// Revisions.....:
//===================================================================

static String
StaticGetName(const DecisionTable &table, int attribute_no, bool masked) {

	String name = table.GetAttributeName(attribute_no, masked);

	name.Replace(' ', '_');
	name.Capitalize();

	return name;

}

//-------------------------------------------------------------------
// Methods for class CPPRuleExporter.
//===================================================================

//-------------------------------------------------------------------
// Constructors/destructor.
//===================================================================

CPPRuleExporter::CPPRuleExporter() {
}

CPPRuleExporter::~CPPRuleExporter() {
}

//-------------------------------------------------------------------
// Methods inherited from Identifier.
//===================================================================

IMPLEMENTIDMETHODS(CPPRuleExporter, CPPRULEEXPORTER, RuleExporter)

bool
CPPRuleExporter::IsApplicable(const Structure &structure, bool /*warn*/) const {
	if (structure.IsA(GENERALRULES))
		return false;
	return structure.IsA(RULES);
}

//-------------------------------------------------------------------
// Methods inherited from Exporter.
//===================================================================

//-------------------------------------------------------------------
// Method........: ExportPrologue
// Author........: Aleksander šhrn
// Date..........:
// Description...: Exports the header (.h) file.
// Comments......:
// Revisions.....:
//===================================================================

bool
CPPRuleExporter::ExportPrologue(ofstream &stream, const Structure &structure) const {

	int i;

	// Cast to already verified type (in Apply method).
	Handle<Rules> rules = dynamic_cast(Rules *, const_cast(Structure *, &structure));

	// Get originating decision table.
	Handle<DecisionTable> table = dynamic_cast(DecisionTable *, rules->FindParent(DECISIONTABLE));

	if (table == NULL) {
		Message::Error("Could not trace back to the rules' originating decision table for a dictionary.");
		return false;
	}

	bool masked = true;

	int no_attributes = table->GetNoAttributes(masked);

	// Write marker.
	stream << "//------------------------------------------------------------------" << endl;
	stream << "// The header (.h) file starts here."                                 << endl;
	stream << "//==================================================================" << endl;
	stream << endl;

	// Write some general information.
	stream << "// Classifier generated by ROSETTA."                                                << endl;
	stream << "// Exported " << SystemKit::GetTimestamp() << " by " << SystemKit::GetUser() << "." << endl;
	stream << "//"                                                                                 << endl;
	stream << "// " << rules->GetName()                                                            << endl;
	stream << "// " << rules->GetNoRules() << " rules."                                            << endl;
	stream << endl;

	// Add #ifndef section.
	stream << "#ifndef __CLASSIFIER_EXPORTED_FROM_ROSETTA_H__" << endl;
	stream << "#define __CLASSIFIER_EXPORTED_FROM_ROSETTA_H__" << endl;
	stream << endl;

	// Define the ROSETTAObject class.
	stream << "//------------------------------------------------------------------" << endl;
	stream << "// Class.........: ROSETTAObject"                                     << endl;
	stream << "// Author........: Aleksander šhrn"                                   << endl;
	stream << "// Date..........: " << SystemKit::GetTimestamp()                     << endl;
	stream << "// Description...: An object input to a ROSETTAClassifier."           << endl;
	stream << "//"                                                                   << endl;
	stream << "//                 For a legend to the encoding of slots for the"     << endl;
	stream << "//                 symbolic attributes, see the Lookup methods."      << endl;
	stream << "//==================================================================" << endl;
	stream << endl;
	stream << "class ROSETTAObject {"                                                << endl;
	stream << "public:"                                                              << endl;
	stream << endl;
	stream << "  // Variable slots................................................." << endl;

	for (i = 0; i < no_attributes; i++) {

		if (!table->IsCondition(i, masked))
			continue;

		// Variable type.
		if (table->IsFloat(i, masked))
			stream << "  float      ";
		else
			stream << "  int        ";

		String name = StaticGetName(*table, i, masked);

		// Variable name.
		stream << name << ';';

		stream << endl;

	}

	stream << endl;
	stream << "  // Dictionary lookup methods......................................" << endl;

	// Method names.
	for (i = 0; i < no_attributes; i++) {
		if (table->IsCondition(i, masked) && table->IsSymbolic(i, masked))
			stream << "  static int Lookup" << StaticGetName(*table, i, masked) << "(const char *text);" << endl;
	}

	stream << endl;
	stream << "};" << endl;
	stream << endl;

	// Determine index of decision attribute.
	int decision_attribute = table->GetDecisionAttribute(masked);

	if (decision_attribute == Undefined::Integer()) {
		Message::Error("No decision attribute detected in parent table.");
		return false;
	}

	Vector(int) decisionvalues;
	Vector(int) cardinalities;

	// Determine set of possible decision values.
	if (!table->GetValueSet(decisionvalues, cardinalities, decision_attribute, masked)) {
		Message::Error("Failed to get set of possible decision values from parent table.");
		return false;
	}

	// Define the ROSETTAClassifier class.
	stream << "//------------------------------------------------------------------"       << endl;
	stream << "// Class.........: ROSETTAClassifier"                                       << endl;
	stream << "// Author........: Aleksander šhrn"                                         << endl;
	stream << "// Date..........: " << SystemKit::GetTimestamp()                           << endl;
	stream << "// Description...: Classifies a ROSETTAObject using a collection of"        << endl;
	stream << "//                 if-then rules."                                          << endl;
	stream << "//"                                                                         << endl;
	stream << "//                 The vote count associated with each decision value"      << endl;
	stream << "//                 is returned in-place in an array. To map from array"     << endl;
	stream << "//                 indices to decision values, see the Classify method."    << endl;
	stream << "//"                                                                         << endl;
	stream << "//                 The descriptor matching methods can be altered to"       << endl;
	stream << "//                 allow for tolerant matching."                            << endl;
	stream << "//=================================================================="       << endl;
	stream << endl;
	stream << "class ROSETTAClassifier {"                                                  << endl;
	stream << "protected:"                                                                 << endl;
	stream << endl;
	stream << "  // Descriptor matching methods...................................."       << endl;

	for (i = 0; i < no_attributes; i++) {

		if (!table->IsCondition(i, masked))
			continue;

		String name = StaticGetName(*table, i, masked);

		// Method name.
		stream << "  bool Match" << name << "(";

		int indent = 15;

		// Method arguments and inlined body.
		if (table->IsFloat(i, masked)) {
			stream << "float value1, float value2";
			indent -= 4;
		}
		else
			stream << "int value1, int value2";

		stream << ") const " << String(' ', indent - name.GetLength()) << "{return (value1 == value2);}" << endl;

	}

	stream << endl;
	stream << "public:"                                                                    << endl;
	stream << endl;
	stream << "  // Classification method.........................................."       << endl;
  stream << "  int  Classify(const ROSETTAObject &object, int votes[" << decisionvalues.size() << "]) const;" << endl;
	stream << endl;
	stream << "};"                                                                         << endl;

	// Match the #ifndef section.
	stream << endl;
	stream << "#endif" << endl;
	stream << endl;

	// Write marker.
	stream << "//------------------------------------------------------------------" << endl;
	stream << "// The header (.h) file ends here."                                   << endl;
	stream << "//==================================================================" << endl;
	stream << endl;

	return true;

}

//-------------------------------------------------------------------
// Method........: ExportData
// Author........: Aleksander šhrn
// Date..........:
// Description...: Exports the implementation (.cpp) file.
// Comments......:
// Revisions.....:
//===================================================================

bool
CPPRuleExporter::ExportData(ofstream &stream, const Structure &structure) const {

	int i, j, k;

	Message message;

	// Cast to already verified type (in Apply method).
	Handle<Rules> rules = dynamic_cast(Rules *, const_cast(Structure *, &structure));

	// Get originating decision table.
	Handle<DecisionTable> table = dynamic_cast(DecisionTable *, rules->FindParent(DECISIONTABLE));

	if (table == NULL) {
		message.Error("Could not trace back to the rules' originating decision table for a dictionary.");
		return false;
	}

	bool masked = true;

	int no_attributes = table->GetNoAttributes(masked);
	int decision_attribute = table->GetDecisionAttribute(masked);

	Vector(int) decisionvalues;
	Vector(int) cardinalities;

	table->GetValueSet(decisionvalues, cardinalities, decision_attribute, masked);

	// Write marker.
	stream << "//------------------------------------------------------------------" << endl;
	stream << "// The implementation (.cpp) file starts here."                       << endl;
	stream << "//==================================================================" << endl;
	stream << endl;

	// Write some general information.
	stream << "// Classifier generated by ROSETTA."                                                << endl;
	stream << "// Exported " << SystemKit::GetTimestamp() << " by " << SystemKit::GetUser() << "." << endl;
	stream << "//"                                                                                 << endl;
	stream << "// " << rules->GetName()                                                            << endl;
	stream << "// " << rules->GetNoRules() << " rules."                                            << endl;
	stream << endl;

	// Add #include section.
	stream << "// To do: Change the name below to whatever you named the header (.h) file." << endl;
	stream << "#include \"" << GetFilename() << "\"" << endl;
	stream << "#include <string.h> // strcmp." << endl;
	stream << "#include <limits.h> // INT_MAX." << endl;
	stream << endl;

	// Add #define section.
	stream << "//------------------------------------------------------------------" << endl;
	stream << "// Method........: Macros"                                            << endl;
	stream << "// Author........: Aleksander šhrn"                                   << endl;
	stream << "// Date..........: " << SystemKit::GetTimestamp()                     << endl;
	stream << "// Description...:"                                                   << endl;
	stream << "//==================================================================" << endl;
	stream << endl;
	stream << "#define ROSETTALOOKUP(description, value) \\"                         << endl;
	stream << "if (0 == strcmp(text, description)) return value;"                    << endl;
	stream << endl;
	stream << "#define ROSETTAMATCH(attribute, value) \\"                            << endl;
	stream << "Match##attribute##(object.##attribute, value)"                        << endl;
	stream << endl;
	stream << "#define ROSETTAVOTE(";

	for (i = 0; i < decisionvalues.size(); i++) {
	  stream << "index" << i << ", votes" << i;
		if (i < decisionvalues.size() - 1)
			stream << ", ";
	}

	stream << ") \\"                                                                 << endl;
	stream << '{';

	for (i = 0; i < decisionvalues.size(); i++) {
	  stream << "votes[index" << i << "] += votes" << i << "; ";
	}

	stream << "no_matches++;}"                                                       << endl;
	stream << endl;

	// Add method header.
	stream << "//------------------------------------------------------------------"                    << endl;
	stream << "// Method........: Lookup methods"                                                       << endl;
	stream << "// Author........: Aleksander šhrn"                                                      << endl;
	stream << "// Date..........: " << SystemKit::GetTimestamp()                                        << endl;
	stream << "// Description...: Converts symbolic values to integers."                                << endl;
	stream << "//=================================================================="                    << endl;
	stream << endl;

	for (i = 0; i < no_attributes; i++) {

		if (!table->IsCondition(i, masked) || !table->IsSymbolic(i, masked))
			continue;

		// Method name.
		stream << "int"                                                                                   << endl;
		stream << "ROSETTAObject::Lookup" << StaticGetName(*table, i, masked) << "(const char *text) {"   << endl;
		stream << endl;

		Vector(int) conditionvalues;

		table->GetValueSet(conditionvalues, cardinalities, i, masked);

		// Method body.
		for (j = 0; j < conditionvalues.size(); j++) {
			String description = table->GetDictionaryEntry(i, conditionvalues[j], masked);
			stream << "  ROSETTALOOKUP(\"" << description << "\", " << String(' ', 25 - description.GetLength()) << conditionvalues[j] << ')' << endl;
		}

		stream << endl;
		stream << "  return INT_MAX;"                                                                     << endl;
		stream << endl;
    stream << "}"                                                                                     << endl;
		stream << endl;

	}

	Map(int, int) decisionmap;

	for (i = 0; i < decisionvalues.size(); i++)
		decisionmap.insert(Pair(const int, int)(decisionvalues[i], i));

	// Build index map.

	int no_rules = rules->GetNoRules();

	// Add method header.
	stream << "//------------------------------------------------------------------"                    << endl;
	stream << "// Method........: Classify"                                                             << endl;
	stream << "// Author........: Aleksander šhrn"                                                      << endl;
	stream << "// Date..........: " << SystemKit::GetTimestamp()                                        << endl;
	stream << "// Description...: Classifies an object using standard voting among"                     << endl;
	stream << "//                 a set of decision rules."                                             << endl;
	stream << "//"                                                                                      << endl;
	stream << "//                 Returns the number of matching rules. In-place is"                    << endl;
	stream << "//                 returned an array with the vote counts for each"                      << endl;
	stream << "//                 decision value. To map from array indices to decision"                << endl;
	stream << "//                 values, use the following legend:"                                    << endl;
	stream << "//"                                                                                      << endl;

	for (Map(int, int)::iterator it = decisionmap.begin(); it != decisionmap.end(); it++)
	  stream << "//                 " << (*it).second << " -> \"" << table->GetDictionaryEntry(decision_attribute, (*it).first, masked) << "\"" << endl;

	stream << "//"                                                                                      << endl;
	stream << "//=================================================================="                    << endl;
	stream << endl;
	stream << "int"                                                                                     << endl;
	stream << "ROSETTAClassifier::Classify(const ROSETTAObject &object, int votes[" << decisionvalues.size() << "]) const {" << endl;
	stream << endl;
	stream << "  int no_matches = 0;"                                                                   << endl;
	stream << endl;

	// Add array initialization.
	stream << "  for (int i = 0; i < " << decisionvalues.size() << "; i++)"                             << endl;
	stream << "    votes[i] = 0;"                                                                       << endl;

	stream << endl;

	bool has_issued_warning = false;

	// Add rules.
	for (i = 0; i < no_rules; i++) {

		if (!message.Progress("Exporting rules...", i, no_rules))
			break;

		Handle<Rule> rule  = rules->GetRule(i);
		int no_descriptors = rule->GetNoConditionDescriptors();
		int no_decisions   = rule->GetNoDecisionValues();

		// Quick sanity check.
		if (rule->GetDecisionAttribute() != decision_attribute) {
			if (!has_issued_warning) {
				message.Warning("Possible mismatch in table and rule set for decision attribute.", false);
				has_issued_warning = true;
			}
		}

		stream << "  if (";

		// Write if-part.
		for (j = 0; j < no_descriptors; j++) {

			int descriptor_attribute = rule->GetConditionAttribute(j);
			int descriptor_value     = rule->GetConditionValue(j);

			String name = StaticGetName(*table, descriptor_attribute, masked);

			// Method name and parameters.
			if (table->IsFloat(descriptor_attribute, masked))
				stream << "ROSETTAMATCH(" << name << ", " << table->GetDictionaryEntry(descriptor_attribute, descriptor_value, masked) << ')';
			else
				stream << "ROSETTAMATCH(" << name << ", " << descriptor_value << ')';

			if (j < no_descriptors - 1)
				stream << " && ";
			else
				stream << ')';

		}

		stream << endl;

		// Write then-part.
		stream << "    ROSETTAVOTE(";
		for (k = 0; k < decisionvalues.size(); k++) {
			bool did_vote = false;
			for (j = 0; j < no_decisions; j++) {
				int decision_value = rule->GetDecisionValue(j);
				int mapped_value   = decisionmap[decision_value];
				if (mapped_value == k) {
					stream << mapped_value << ", " << rule->GetSupport(j);
					did_vote = true;
					break;
				}
			}
			if (!did_vote) {
				stream << k << ", 0";
			}
			if (k < decisionvalues.size() - 1)
				stream << ", ";
		}
		stream << ')' << endl;
		stream << endl;

	}

	stream << "  return no_matches;" << endl;
	stream << endl;
	stream << '}' << endl;
	stream << endl;

	// Write marker.
	stream << "//------------------------------------------------------------------" << endl;
	stream << "// The implementation (.cpp) file ends here."                         << endl;
	stream << "//==================================================================" << endl;
	stream << endl;

	return true;

}

//-------------------------------------------------------------------
// Methods inherited from RuleExporter.
//===================================================================

//-------------------------------------------------------------------
// Method........: ExportRule
// Author........: Aleksander šhrn
// Date..........:
// Description...:
// Comments......:
// Revisions.....:
//===================================================================

bool
CPPRuleExporter::ExportRule(ofstream &/*stream*/, int /*rule_no*/, const Rule &/*rule*/) const {
	return false;
}
 
CPPRuleExporter *
CPPRuleExporter::Clone() {
	return new CPPRuleExporter;
}
