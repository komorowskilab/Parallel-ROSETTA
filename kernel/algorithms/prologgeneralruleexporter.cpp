//-------------------------------------------------------------------
// Author........: Ewa Makosa
// Date..........:
// Description...:
// Revisions.....:
//===================================================================

#include <stdafx.h> // Precompiled headers.
#include <copyright.h>
#include <kernel/algorithms/prologgeneralruleexporter.h>
#include <kernel/structures/generalrules.h>
#include <kernel/structures/generalrule.h>
#include <kernel/utilities/systemkit.h>
#include <kernel/system/fstream.h>

//-------------------------------------------------------------------
// Methods for class PrologGeneralRuleExporter.
//===================================================================

//-------------------------------------------------------------------
// Constructors/destructor.
//===================================================================

PrologGeneralRuleExporter::PrologGeneralRuleExporter() {
}

PrologGeneralRuleExporter::~PrologGeneralRuleExporter() {
}

//-------------------------------------------------------------------
// Methods inherited from Identifier.
//===================================================================

IMPLEMENTIDMETHODS(PrologGeneralRuleExporter, PROLOGGENERALRULEEXPORTER, RuleExporter)

//-------------------------------------------------------------------
// Methods inherited from Algorithm.
//===================================================================

//-------------------------------------------------------------------
// Method........: IsApplicable
// Author........: Ewa Makosa
// Date..........:
// Description...:
// Comments......:
// Revisions.....: 
//===================================================================

bool
PrologGeneralRuleExporter::IsApplicable(const Structure &structure, bool /*warn*/) const {
	return structure.IsA(GENERALRULES);
}

//-------------------------------------------------------------------
// Methods inherited from Exporter.
//===================================================================

//-------------------------------------------------------------------
// Method........: ExportPrologue
// Author........: Ewa Makosa
// Date..........:
// Description...:
// Comments......: Assumes non-deterministic rules are expanded into
//                 several Prolog rules, for counting to be correct.
//                 Cf. Rule::FormatProlog method. All the generalized
//		   values are also expanded to form several rules.
// Revisions.....:
//===================================================================

bool
PrologGeneralRuleExporter::ExportPrologue(ofstream &stream, const Structure &structure) const {

	// Cast to already verified type (in Apply method).
	Handle<GeneralRules> rules = dynamic_cast(GeneralRules *, const_cast(Structure *, &structure));

	// Write some general information.
	stream << "% Rules/patterns generated by ROSETTA." << endl;
	stream << "% Exported " << SystemKit::GetTimestamp() << " by " << SystemKit::GetUser() << "." << endl;
	stream << "%" << endl;
	stream << "% " << rules->GetName() << endl;
	stream << "%" << endl;
	stream << "% Clause head arguments: (Object, Decision, Support, Accuracy, Stability)" << endl;
	stream << "%" << endl;

	int no_deterministic    = 0;
	int no_nondeterministic = 0;
	int no_total            = 0;
	int no_rules            = rules->GetNoRules();

	int i, b, d;

	// Do some counting.
	for (i = 0; i < no_rules; i++) {
		Handle<GeneralRule> rule = rules->GetRule(i);
		b = 1;
		for (d = 0; d < rule->GetNoConditionDescriptors(); d++){
			b *= rule->GetNoConditionValues(d);
		}
		if (rule->IsDeterministic()) {
			no_deterministic += b;
			no_total	+= b;
		}
		else {
			no_nondeterministic += b;
			no_total += rule->GetNoDecisionValues()*b;
		}
	}

	// Write some dimensional information.
	stream << "% " << no_rules			  << " rules/patterns in rosetta format."                << endl;
	stream << "% " << no_deterministic    << " deterministic rules/patterns."                << endl;
	stream << "% " << no_nondeterministic << " non-deterministic rules/patterns (expanded)." << endl;
	stream << "% " << no_total            << " Prolog rules/patterns in total."              << endl;
	stream << endl;

	return true;

}

//-------------------------------------------------------------------
// Method........: ExportRule
// Author........: 
// Date..........:
// Description...: Overloaded to deal with Prolog syntax.
// Comments......:
// Revisions.....:
//===================================================================

bool
PrologGeneralRuleExporter::ExportRule(ofstream &stream, int /*rule_no*/, const GeneralRule &rule) const {

	String formatted;

	bool masked = true;

	// Generate Prolog format.
	if (!rule.FormatProlog(formatted, GetDecisionTable(), masked)) {
		Message::Error("Error formatting rule.");
		return false;
	}

	// Dump formatted rule to file stream.
	stream << formatted << endl << endl;

	return true;

}

PrologGeneralRuleExporter *
PrologGeneralRuleExporter::Clone() {
   return new PrologGeneralRuleExporter;
} 
