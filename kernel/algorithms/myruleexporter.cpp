//-------------------------------------------------------------------
// Author........: Aleksander šhrn
// Date..........:
// Description...:
// Revisions.....:
//===================================================================

#include <stdafx.h> // Precompiled headers.
#include <copyright.h>

#include <kernel/algorithms/myruleexporter.h>

#include <kernel/structures/rules.h>
#include <kernel/structures/rule.h>

#include <kernel/utilities/systemkit.h>

#include <kernel/system/fstream.h>


//-------------------------------------------------------------------
// Methods for class MyRuleExporter.
//===================================================================

//-------------------------------------------------------------------
// Constructors/destructor.
//===================================================================

MyRuleExporter::MyRuleExporter() : bOR_(false), bRR_(false), fCI_(0.0) {
}

MyRuleExporter::~MyRuleExporter() {
}

//-------------------------------------------------------------------
// Methods inherited from Identifier.
//===================================================================

IMPLEMENTIDMETHODS(MyRuleExporter, MYRULEEXPORTER, RuleExporter)

//-------------------------------------------------------------------
// Methods inherited from Exporter.
//===================================================================

//-------------------------------------------------------------------
// Method........: ExportPrologue
// Author........: Aleksander šhrn
// Date..........:
// Description...:
// Comments......: Consider using IOKit instead.
// Revisions.....: 28/10/14 -N
// 			Added information on the decision system, with more
// 			detailed information of the decision attribute and its
// 			cardinalities with respect to decision classes.
//===================================================================

bool
MyRuleExporter::ExportPrologue(ofstream &stream, const Structure &structure) const {

	// Cast to already verified type (in Apply method).
	Handle<Rules> rules = dynamic_cast(Rules *, const_cast(Structure *, &structure));

	bool masked = true;

	Vector(int) vCards;
	Vector(int) vValues;

	GetDecisionTable()->GetValueSet(vValues, vCards, GetDecisionTable()->GetDecisionAttribute(masked), masked);
	// Write some general information.
	stream << "% Rules/patterns generated by ROSETTA." << endl;
	stream << "% Exported " << SystemKit::GetTimestamp() << " by " << SystemKit::GetUser() << "." << endl;
	stream << "%" << endl;
	stream << "% " << rules->GetName() << endl;
	stream << "% " << rules->GetNoRules() << " rules." << endl;
	stream << "% " << endl;
	stream << "% Decision Table contains:" << endl;
	stream << "% " << GetDecisionTable()->GetNoObjects(masked) << " objects." << endl;
	stream << "% " << GetDecisionTable()->GetNoAttributes(masked) << " features." << endl;
	stream << "% " << vValues.size() << " decision values: ";
	for (int i = 0; i < vValues.size() - 1; ++i) {
		stream << GetDecisionTable()->GetDictionaryEntry(GetDecisionTable()->GetDecisionAttribute(masked), vValues[i], masked) << " (" << vCards[i] << "), ";
	}
	stream << GetDecisionTable()->GetDictionaryEntry(GetDecisionTable()->GetDecisionAttribute(masked), vValues.back(), masked) << " (" << vCards.back() << ")" << endl;
	stream << endl;

	return true;

}

//-------------------------------------------------------------------
// Methods inherited from RuleExporter.
//===================================================================

//-------------------------------------------------------------------
// Method........: ExportRule
// Author........: Aleksander šhrn
// Date..........:
// Description...: Overloaded to deal with this particular rule syntax.
// Comments......:
// Revisions.....: 24/10/14 -N
// 			Added Odds Ratio calculations to the bottom.
// 			Currently nabs the decision vector data through GetValues,
// 			an inefficient way to do it (since all rules generated will
// 			rely on the very same decision), but ultimately easy to implement
// 			and understand as it does not require editing the input of an
// 			overloaded function.
// 		   21/01/19 -N
// 		   	Removed Stability from single decision rules. No point in
// 		   	keeping that since it only complicates compatibility with
// 		   	Visunet.
//===================================================================

bool
MyRuleExporter::ExportRule(ofstream &stream, int /*rule_no*/, const Rule &rule) const {

	String formatted;

	bool masked = true;

	// Format rule.
	if (!rule.Format(formatted, GetDecisionTable(), masked)) {
		Message::Error("Error formatting rule.");
		return false;
	}

	// Dump formatted rule to file stream.
	stream << formatted << endl;

	int no_decision_values = rule.GetNoDecisionValues();

	// Dump supports to file stream.
	stream << "Supp. (LHS) = [" << rule.GetSupport() << " object(s)" << "]" << endl;
	stream << "Supp. (RHS) = [";

	int i;

	for (i = 0; i < no_decision_values; i++) {
		stream << rule.GetSupport(i) << " object(s)";
		if (i < (no_decision_values - 1))
			stream << ", ";
	}

	stream << "]" << endl;

	// Dump probabilities to file stream.
	stream << "Acc.  (RHS) = [";

	for (i = 0; i < no_decision_values; i++) {
		stream << rule.GetAccuracy(i);
		if (i < (no_decision_values - 1))
			stream << ", ";
	}

	stream << "]" << endl;

	// Dump coverages to file stream.
	stream << "Cov.  (LHS) = [" << rule.GetCoverage(no_objects_) << "]" << endl;

	stream << "Cov.  (RHS) = [";

	for (i = 0; i < no_decision_values; i++) {
		float coverage = rule.GetCoverage(i, decisions_, cardinalities_);
		if (coverage == Undefined::Float())
			stream << Undefined::String();
		else
			stream << coverage;
		if (i < (no_decision_values - 1))
			stream << ", ";
	}

	stream << "]" << endl;
	
	//No more stability.
/*
	// Dump stabilities to file stream.
	stream << "Stab. (LHS) = [" << rule.GetStability() << "]" << endl;

	stream << "Stab. (RHS) = [";

	for (i = 0; i < no_decision_values; i++) {
		stream << rule.GetStability(i);
		if (i < (no_decision_values - 1))
			stream << ", ";
	}

	stream << "]" << endl;
*/
	// OR calculations. Kept separate for ease of identification.
	if (GetOR() && no_decision_values > 1) {

		float nDe, nDn, nHe, nHn, nOR;
		/*
			De = Diseased and matching rule.
			Dn = Diseased but not matching rule.
			He = Not diseased and matching rule.
			Hn = Not diseased and not matching rule
			OR is calculated as (De / Dn) / ( He / Hn)
		*/

		Vector(int) vDecisionValues;
		Vector(int) vCardinalities;
		int nDecisionIndex = GetDecisionTable()->GetDecisionAttribute(masked);
		//For CIs. Declared in general to avoid scoping issues.
		double dOneSidedAlpha = GetCI() / 2;
		
		GetDecisionTable()->GetValueSet(vDecisionValues, vCardinalities, nDecisionIndex, masked);
		

		

		stream << "Odds Ratio  = [";

		for (i = 0; i < no_decision_values; ++i) {
			//nDe is the RHS support. (i.e. Number of objects that match RHS given LHS i)
			nDe = static_cast(float, rule.GetSupport(i));

			//nHe is the number of objects that match LHS but not RHS
			nHe = static_cast(float, rule.GetSupport()) - nDe;

			//nDn is the number of objects in the same decision class, but not matching LHS
			nDn = static_cast(float, vCardinalities[rule.GetDecisionValue(i)]) - nDe;

			//nHn is the number of healthy and non-exposed.
			nHn = (static_cast(float, GetDecisionTable()->GetNoObjects(masked)) - static_cast(float, vCardinalities[rule.GetDecisionValue(i)])) - nHe;
			//std::cout << "nDe, nDn, nHe, nHn :" << nDe << ", " << nDn << ", " << nHe << ", " << nHn << endl;

			//Incase of weird stuff, print failure.
			if (nDn != 0 && nHe != 0 && nHn != 0) {	
				nOR = (nDe * nHn) / (nHe * nDn);
				stream << nOR;

				//Confidence Intervals on the odds ratios.
				if (GetComputeCI()) {
					
					//Get natural log of OR.
					double dLN = log(nOR);
					//Get standard error of OR.
					double dSE = sqrt( (1 / nDe) + (1 / nDn) + (1 / nHe) + (1 / nHn));
					//Get upper bound.
					double dUB = dLN + 1.96 * dSE;
					//And lower bound.
					double dLB = dLN - 1.96 * dSE;
			
					//The lower bound of the CI. Takes LHS support, RHS support, a one-sided alpha value (alpha from input, divided above), using the mathematical model set by SetCI().
					//double dLowerBound = binomial_distribution<>::find_lower_bound_on_p(rule.GetSupport(), nDe, dOneSidedAlpha, GetCI());

					//The upper bound of the CI. Takes LHS support, RHS support, a one-sided alpha value (alpha from input, divided above), and using the mathematical model set by SetCI().
					//double dUpperBound = binomial_distribution<>::find_upper_bound_on_p(rule.GetSupport(), nDe, dOneSidedAlpha, GetCI());
			
					//Printing stuff.
					stream << " (" << exp(dLB) << " - " << exp(dUB) << ")"; 
				}
			}
			else {
				stream << "X";
			}


			//Add , or not depending on further additions.
			if (i < no_decision_values - 1) {
				stream << ", ";
			}

		}
	
		stream << "]" << endl;
	}

	//RR calculations. Kept separate for ease.
	if (GetRR() && no_decision_values > 1) {


		float fA, fB, fC, fD, fRR;

		//fA = Number of exposed objects matching rule (diseased). X = true, d = true.
		//fB = Number of exposed objects not matching rule (healthy). X = true, d = false.
		//fC = Number of non-exposed objects matching rule. X = false, d = true.
		//fD = Number of non-exposed objects not matching rule. X = false, d = false.
		//RR is calculated as (a / (a +b)) / (c / (c + d))
	
		Vector(int) vDecisionValues;
		Vector(int) vCardinalities;
		int nDecisionIndex = GetDecisionTable()->GetDecisionAttribute(masked);
		
		GetDecisionTable()->GetValueSet(vDecisionValues, vCardinalities, nDecisionIndex, masked);
		
		stream << "Risk Ratio  = [";

		for (i = 0; i < no_decision_values; ++i) {

			//fA = RHS.
			fA = static_cast(float, rule.GetSupport(i));
			//fB = LHS - fA.
			fB = static_cast(float, rule.GetSupport()) - fA;
			//fC = Cardinality of the decision i - fA.
			fC = static_cast(float, vCardinalities[rule.GetDecisionValue(i)]) - fA;
			//Universe - fA - fB - fC. 
			fD = ((static_cast(float, GetDecisionTable()->GetNoObjects(masked)) - fA) - fB) - fC;
		
			if (fC != 0 && fD != 0) {

				fRR = (fA / (fA + fB)) / (fC / (fC + fD));
				stream << fRR;

				if (GetComputeCI()) {
				
					//Get natural log of RR.
					double dLN = log(fRR);
					//Get standard error of RR.
					double dSE = sqrt( fB / (fA * (fA + fB)) + fD / (fC * (fC + fD)));
					//Get upper bound.
					double dUB = dLN + 1.96 * dSE;
					//And lower bound.
					double dLB = dLN - 1.96 * dSE;
			
					//The lower bound of the CI. Takes LHS support, RHS support, a one-sided alpha value (alpha from input, divided above), using the mathematical model set by SetCI().
					//double dLowerBound = binomial_distribution<>::find_lower_bound_on_p(rule.GetSupport(), nDe, dOneSidedAlpha, GetCI());

					//The upper bound of the CI. Takes LHS support, RHS support, a one-sided alpha value (alpha from input, divided above), and using the mathematical model set by SetCI().
					//double dUpperBound = binomial_distribution<>::find_upper_bound_on_p(rule.GetSupport(), nDe, dOneSidedAlpha, GetCI());
			
					//Printing stuff.
					stream << " (" << exp(dLB) << " - " << exp(dUB) << ")"; 
				}
			}
			else {
				stream << "X";
			}
			if (i < no_decision_values - 1) {
				stream << ", ";
			}
		}

		stream << "]" << endl;
	}

	stream << endl;

	return true;

}

//-------------------------------------------------------------------
// Method........: SetParameter
// Author........: Nicholas Baltzer
// Date..........: 24/11/14
// Description...: Adds the possibility of taking parameters and setting options to MyRuleExporter.
// Comments......: Added for setting Odds Ratios and Risk Ratios as optional values. The last line
// 			calls RuleExporter::SetParameter, even though it holds no parameters. This is done
// 			for consistency of design and extendability.
// Revisions.....: 20/02/15 -N
// 			Added parameter settings for Confidence intervals.
//===================================================================

bool
MyRuleExporter::SetParameter(const String &keyword, const String &value) {

	//Use Odds ratios in the export.
	if (keyword == Keyword::WithOR()) {
		return SetOR();
	}

	//Use Risk ratios in the export.
	if (keyword == Keyword::WithRR()) {
		return SetRR();
	}

	//Use confidence intervals. Requires OR. Defaults to 95%.
	if (keyword == Keyword::WithCI()) {
		return SetCI(value);
	}

	
	return RuleExporter::SetParameter(keyword, value);
}

//-------------------------------------------------------------------
// Method........: GetParameters
// Author........: Nicholas Baltzer
// Date..........: 24/11/14
// Description...: Grabs the parameters set.
// Comments......: Still uses String :(
// Revisions.....: 20/02/15 -N
// 			Added Confidence Interval stuff.
//===================================================================

String
MyRuleExporter::GetParameters() const {

	String sParameters;

	//RuleExporter::GetParameters() is currently empty, and RuleExporter does not take parameters.
	//It is added here nonetheless (and SetParameters has been added to RuleExporter nonetheless)
	//to conform to the expected style, and to allow for quick extension of the RuleExporter super-class.
	sParameters += RuleExporter::GetParameters() + Keyword::Separator();

	if (GetOR()) {
		sParameters += Keyword::WithOR();
		sParameters += Keyword::Separator();
		if (GetCI()) {
			sParameters += Keyword::WithCI();
			sParameters += Keyword::Assignment();
			sParameters += String::Format(GetCI());
		}
	}
	if (GetRR()) {
		sParameters += Keyword::WithRR();
		sParameters += Keyword::Separator();
	}

	return sParameters;


}


MyRuleExporter *
MyRuleExporter::Clone() {
	return new MyRuleExporter;
}
