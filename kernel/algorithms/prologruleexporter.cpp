//-------------------------------------------------------------------
// Author........: Aleksander šhrn
// Date..........:
// Description...:
// Revisions.....:
//===================================================================

#include <stdafx.h> // Precompiled headers.
#include <copyright.h>

#include <kernel/algorithms/prologruleexporter.h>

#include <kernel/structures/rules.h>
#include <kernel/structures/rule.h>

#include <kernel/utilities/systemkit.h>

#include <kernel/system/fstream.h>

//-------------------------------------------------------------------
// Methods for class PrologRuleExporter.
//===================================================================

//-------------------------------------------------------------------
// Constructors/destructor.
//===================================================================

PrologRuleExporter::PrologRuleExporter() {
}

PrologRuleExporter::~PrologRuleExporter() {
}

//-------------------------------------------------------------------
// Methods inherited from Identifier.
//===================================================================

IMPLEMENTIDMETHODS(PrologRuleExporter, PROLOGRULEEXPORTER, RuleExporter)

bool
PrologRuleExporter::IsApplicable(const Structure &structure, bool /*warn*/) const {
	if (structure.IsA(GENERALRULES))
		return false;
	return structure.IsA(RULES);
}
//-------------------------------------------------------------------
// Methods inherited from Exporter.
//===================================================================

//-------------------------------------------------------------------
// Method........: ExportPrologue
// Author........: Aleksander šhrn
// Date..........:
// Description...:
// Comments......: Assumes non-deterministic rules are expanded into
//                 several Prolog rules, for counting to be correct.
//                 Cf. Rule::FormatProlog method.
// Revisions.....:
//===================================================================

bool
PrologRuleExporter::ExportPrologue(ofstream &stream, const Structure &structure) const {

	// Cast to already verified type (in Apply method).
	Handle<Rules> rules = dynamic_cast(Rules *, const_cast(Structure *, &structure));

	// Write some general information.
	stream << "% Rules/patterns generated by ROSETTA." << endl;
	stream << "% Exported " << SystemKit::GetTimestamp() << " by " << SystemKit::GetUser() << "." << endl;
	stream << "%" << endl;
	stream << "% " << rules->GetName() << endl;
	stream << "%" << endl;
	stream << "% Clause head arguments: (Object, Decision, Support, Accuracy, Stability)" << endl;
	stream << "%" << endl;

	int no_deterministic    = 0;
	int no_nondeterministic = 0;
	int no_total            = 0;
	int no_rules            = rules->GetNoRules();

	int i;

	// Do some counting.
	for (i = 0; i < no_rules; i++) {
		Handle<Rule> rule = rules->GetRule(i);
		if (rule->IsDeterministic()) {
			no_deterministic++;
			no_total++;
		}
		else {
			no_nondeterministic++;
			no_total += rule->GetNoDecisionValues();
		}
	}

	// Write some dimensional information.
	stream << "% " << no_deterministic    << " deterministic rules/patterns."                << endl;
	stream << "% " << no_nondeterministic << " non-deterministic rules/patterns (expanded)." << endl;
	stream << "% " << no_total            << " Prolog rules/patterns in total."              << endl;
	stream << endl;

	return true;

}

//-------------------------------------------------------------------
// Methods inherited from RuleExporter.
//===================================================================

//-------------------------------------------------------------------
// Method........: ExportRule
// Author........: Aleksander šhrn
// Date..........:
// Description...: Overloaded to deal with Prolog syntax.
// Comments......:
// Revisions.....:
//===================================================================

bool
PrologRuleExporter::ExportRule(ofstream &stream, int /*rule_no*/, const Rule &rule) const {

	String formatted;

	bool masked = true;

	// Generate Prolog format.
	if (!rule.FormatProlog(formatted, GetDecisionTable(), masked)) {
		Message::Error("Error formatting rule.");
		return false;
	}

	// Dump formatted rule to file stream.
	stream << formatted << endl << endl;

	return true;

}

PrologRuleExporter *
PrologRuleExporter::Clone() {
   return new PrologRuleExporter;
} 
